import math

def func(x):
    # Пример многомодальной функции
    return math.cos(x) + (10*x - x**2)/50

# ВАЖНО: Это Метод Ломаных (Пиявского), а не Хорд!
def broken_line_method(f, a=0, b=10, eps=1e-5, max_iter=1000, L=1.2):
    # 1. Начальная инициализация (по краям отрезка)
    # Считаем, что мы уже измерили f(a) и f(b), поэтому счетчик = 2
    cnt = 2 
    
    # Формула вершины первого "конуса" между a и b
    # См. учебник стр. 60 (формулы для x и y)
    x_start = (a + b) / 2 + (f(a) - f(b)) / (2 * L)   
    phi_start = (f(a) + f(b)) / 2 - L * (b - a) / 2
    
    # Списки X и Phi хранят координаты вершин ломаной (потенциальные минимумы)
    X = [x_start]
    Phi = [phi_start]
    
    while cnt < max_iter:
        # 2. Находим самую низкую точку ломаной (глобальный минимум миноранты)
        # Это "наилучшая надежда" найти минимум
        k = min(range(len(Phi)), key=lambda i: Phi[i])
        x_i = X[k]
        phi_i = Phi[k] # Это наша нижняя граница (оценка)

        # 3. Делаем замер реальной функции в этой точке
        f_val = f(x_i)  
        cnt += 1

        # 4. Критерий остановки (стр. 63)
        # Если разница между реальным значением и нижней оценкой мала
        if (f_val - phi_i) < eps:
            return x_i, f_val, cnt

        # 5. Перестроение ломаной (разбиение одной ямки на две)
        # Мы удаляем старую вершину и добавляем две новые, уточненные замером f_val
        delta = (f_val - phi_i) / (2 * L)

        x_new1 = x_i + delta # Вершина справа
        x_new2 = x_i - delta # Вершина слева
        phi_new = (f_val + phi_i) / 2 # Новая высота вершин

        X.pop(k)
        Phi.pop(k)

        X.append(x_new1)
        Phi.append(phi_new)
        X.append(x_new2)
        Phi.append(phi_new)
        
    return X[0], f(X[0]), cnt # Если превышен лимит итераций

# Запуск
xmin, fmin, iters = broken_line_method(func)
print(f'Найден x: {xmin:.5f}')
print(f'Значение f(x): {fmin:.5f}')
print(f'Количество вычислений: {iters}')